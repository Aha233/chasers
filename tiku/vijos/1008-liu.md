# 1008
## 题目  
**[题目描述]**  
佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有n个同学，编号从1到n。一开始，同学们按照`1，2，……，n`的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。  

佳佳可向同学们下达命令，每一个命令的形式如下： 

`(b1, b2,... bm -1, bm)`

这里m的值是由佳佳决定的，每次命令`m`的值都可以不同。这个命令的作用是移动编号是`b1，b2，…… bm –1，bm`的这m个同学的位置。要求`b1`换到`b2`的位置上，`b2`换到`b3`的位置上，……，要求`bm`换到`b1`的位置上。  

执行每个命令都需要一些代价。我们假定如果一个命令要移动`m`个人的位置，那么这个命令的代价就是`m`。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗?  

对于30%的数据，`n <= 1000`；  
对于全部的数据，`n <= 50000`。  

**[输入描述]**   
输入的第一行是一个整数`n（3 <= n <= 50000）`，表示一共有n个同学。其后n行每行包括两个不同的正整数，以一个空格隔开，分别表示编号是1的同学最希望相邻的两个同学的编号，编号是2的同学最希望相邻的两个同学的编号，……，编号是n的同学最希望相邻的两个同学的编号。  

**[输出描述]**  
输出包括一行，这一行只包含一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出-1。  

**[输入样例]**  
4  
3 4  
4 3  
1 2  
1 2  

**[输出样例]**  
2  

## 讲解    
1）如样例，有4个同学，按1，2，3，4编号。  
给出4位同学最希望相邻的两个同学的编号  
比如第1位同学希望与3和4相邻，第2位同学希望与4和3相邻，……  

2）如上，写出初始序列和目标序列如下:  
初始序列：1，2，3，4  
目标序列：1，3，2，4（注意是环状）  

3）观察上面的两组序列，可看出只需要移动其中的两人即可，也就是移动不在目标位的人  

4）问题是如何生成目标序列？  

5）将1放在第一位，则下一位就应该是1所希望的人，用b[i]表示目标序列，g[i][0]和g[i][1]表示第i个同学最希望相邻的同学，则有：b[0]=0;b[1]=g[0][0];  

6）对于目标序列的其他位，都依次判断左边的同学是不是两个最希望相邻的同学之一，如果是，则把另一位同学排在右边，如果两个都不是，则意味着最后无论怎样调整都不行。  

7）有目标序列后，只要顺序和逆序分别求目标序列和初始序列的差值，并找出其中出现最多的数即可，比如：  
初始序列：1，2，3，4  
目标序列：1，3，2，4  
\------------------------------  
差值：      0，1，3，0  
用目标序列减初始序列，为了避免出现负号，可将负的差值+n，再%n，也就是环状的效果  

8）上述差值中，0出现得最多，记录其出现的人数，那么n-最多的差值数，则为要调整的人数  

## 代码   

```cpp
#include <iostream>  
#include <cstdio>  
#define N 50002  

using namespace std;  

int n,g[N][2],b[N],f[N][2],ans;  
int init()  
{  
	b[0]=0;						//目标序列的第1个同学编号为1  
	b[1]=g[0][0];				//目标序列的第2个同学为g[0][0]，也就是编号为1的同学最希望相邻的第一个同学编号，  
	for(int i=1;i<n-1;i++)		//目标序列的前一个同学如果正好是第i个同学所希望相邻的第一个  
		if(b[i-1]==g[b[i]][0])	//则其右边则是第i个同学所希望相邻的另一个同学  
	    	b[i+1]=g[b[i]][1];  
		else if(b[i-1]==g[b[i]][1])  
	  		b[i+1]=g[b[i]][0];  
	  	else  
  	  	      return 0;				//如果两边都不符合要求，则意味着无法调整  
	return 1;  
}  

int solve()							//比较目标环与初始环最多有几个位置的元素相同，并求出结果   
{  
	for(int i=0;i<n;i++)  
	{  
		f[(b[i]-i+n)%n][0]++;  
		f[(b[n-1-i]-i+n)%n][1]++;  
	}   
	for(int i=0;i<n;i++)  
		ans=max(ans,max(f[i][0],f[i][1]));  
	return n-ans;  
}  

int main()  
{  
	scanf("%d",&n);					//输入人数  
	for(int i=0;i<n;i++)  
	{  
		scanf("%d%d",&g[i][0],&g[i][1]);	//输入第i个同学最希望相邻的两个同学的编号  
		g[i][0]--;						//将编号改为从0开始的序号，方便后面取模  
		 g[i][1]--;  
	}   
	if(init())							//如果能够调整  
		printf("%d\n",solve());			//则输出需要调整的人数   
	else  
		printf("-1\n");  
	return 0;  
}  
```

## 参考链接  
无  

