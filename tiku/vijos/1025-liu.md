# 1025
## 题目  
**[题目描述]**  
经过抽签选择，小智将军第一个进入考场。  

菜虫：（身上散射出华贵（?）的光芒）欢迎你，第一位挑战者！！
小智：……（走到菜虫身后，关灯）女王陛下，虽然我们国家现在很富裕，但也请您不要浪费电来用这么大功率的灯泡。  

菜虫（汗）：啊啊\~~爱卿所言甚是\~~那么，你的题目是……我们的情报组织探听到敌人的重要将领——小飞侠星期天会邀他的灵儿妹妹到公园去玩。公园里有很多娱乐项目，可并不是每一项他们都喜欢，所以他们对每一项都进行了“喜欢度”的评分。因为小飞侠也是一个了不起的角色，所以他一定会选择在有限时间内的最好的方案。现在要你做的就是找出在规定时间内他们选择哪几项不同的活动可以使其“喜欢度”之和达到最大，据此我们就可以知道他会在哪些地方出现，从而在那里派人看守了。   

**[输入描述]**   
第一行一个正整数`N（1<=N<=100）`表示总共的娱乐项目数；第二行一个正整数表示规定的时间`t（0<t<1000）`；下面有`N`行，其中第`i+2`行有两个正整数`fi（0<=fi<=100）`和`ti（0<ti<=100）`，分别表示对项目`i`的“喜欢度”和它所耗费的时间。  

**[输出描述]**  
输出一行，表示最大的“喜欢度”之和。  

**[输入样例]**  
3  
5  
1 2  
5 5  
4 3  

**[输出样例]**  
5  

## 讲解    
本题是典型的01背包问题，也就是针对一个游乐项目小飞侠只有两种选择：不玩（0）和玩（1）。在规定时间内，小飞侠选择哪些游乐项目才能使欢喜度之和最大。  
我们用数组`num[i][j]`表示，在只有i个娱乐项目，时间为j的情况下的最优解。当娱乐项目数变为`i+1`时，如果第`i+1`个项目的时间`t[i+1]`小于`j`，第`i+1`个项目可以选择玩或者不玩，选择玩那么`num[i+1][j]=num[i][j-t[i]]+f[i]`，选择不玩则`num[i+1][j]=num[i][j]`。  
这时即得出状态转移方程：`num[i+1][j]=max(num[i][j],num[i][j-t[i]]+f[i])`  

在此基础上，我们可以进一步进行空间优化。计算`num[i][j]`时只使用了`num[i-1][0……j]`，没有使用`num[i-1][j+1]`这样的话，我们先计算j的循环时，让`j=M……1`，只使用一个一维数组即可。  
此时的状态转移方程为：`num[j]=max(num[j],num[j-t[i]+f[i])`  

[条件运算符](a)  
[函数的定义与调用](a)  
[01背包问题](a)   

## 代码   
优化前，二维：  

```cpp
#include<iostream>  

using namespace std;  

int N,T,f[101],t[101];  //分别表示娱乐项目数，规定时间，对项目i的“喜欢度”和它所耗费的时间  
int num[101][1001]={0};      //规定时间内所玩娱乐项目“喜欢度”之和的最大值  

int max(int x,int y)   
{
	return x>y?x:y;  
}  

int main()  
{  
	cin>>N>>T;  
	for(int i=1;i<=N;i++)  
		cin>>f[i]>>t[i];  
	for(int i=1;i<=N;i++)  
		for(int j=T;j>=1;j--)  
		{  
			if(t[i]<=j)    //当第i个项目的时间t小于剩余时间j时，才能考虑是否被选择  
				num[i][j]=max(num[i-1][j],num[i-1][j-t[i]]+f[i]);  
			else  
				num[i][j]=num[i-1][j];  
		}   
	cout<<num[N][T]<<endl;  
	return 0;  
}  
```  

空间优化后，二维变一维：
```cpp
#include<iostream>   

using namespace std;  

int N,T,f[101],t[101];  //分别表示娱乐项目数，规定时间，对项目i的“喜欢度”和它所耗费的时间  
int num[1001]={0};      //规定时间内所玩娱乐项目“喜欢度”之和的最大值  

int max(int x,int y)  
{  
	return x>y?x:y;  
}  

int main()  
{  
	cin>>N>>T;  
	for(int i=1;i<=N;i++)  
		cin>>f[i]>>t[i];  
	for(int i=1;i<=N;i++)  
		for(int j=T;j>=1;j--)  
			if(t[i]<=j)    //当第i个项目的时间t小于剩余时间j时，才能考虑是否被选择。  
				num[j]=max(num[j],num[j-t[i]]+f[i]);  
	cout<<num[T]<<endl;  
	return 0;  
}  
```

## 参考链接
[01背包问题--动态规划](https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html)  
