# C6.6 函数匹配
在大多数情况下，我们容易确定某次调用应该选用哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换得来时，这项工作就不那么容易了。

以下面这组函数及其调用为例：
```cpp
void f();
void f(int);
void f(int,int);
void f(double,double = 3.14);
f(5.6);    //调用void f(double,double)
```

**确定候选函数和可行函数**

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为**候选函数（candidate function）**。 

候选函数具备两个特征：
- 与被调用的函数同名
- 其声明在调用点可见

第二步考察本次调用的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数（viale function）**。

可行函数也有两个特征：
- 其形参数量与本次调用提供的实参数量相等
- 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型

我们能根据实参的数量从候选函数中排除两个。不能使用形参的函数和使用两个`int`形参的函数显然都不适合本次调用，这是因为我们的调用只提供了一个实参，而它们分别有0个和两个形参。

使用一个`int`形参的函数和使用两个`double`形参的函数是可行的，它们都能够一个实参调用。最终最后那个函数本应该接收两个`double`值，但是因为它含有一个默认实参，所以只用一个实参也能调用它。

在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否和形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。

在上面的例子中，剩下的两个函数都是可行的：
- `f(int)`是可行的，因为实参类型`double`能转换成形参类型`int`
- `f(double,double)`是可行的，因为它的第二个形参提供了默认值，而第一个形参类型正好是`double`，与函数使用的参数类型一致

**寻找最佳匹配（如果有的话）**  

函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。

在我们的例子中，调用只提供了一个（显式的）实参，它的类型是`double`。如果调用`f(int)`，实参不得不从`double`转换成`int`。另一个可行函数`f(double,double)`则与实参精确匹配。精确匹配比需要类型转换的匹配更好，因此，编译器把`f(5.6)`解析成对含有两个`double`形参的函数的调用，并使用默认值填补我们未提供的第二个实参。

**含有多个形参的函数匹配**  

但实参的数量有两个或更多时，函数匹配就比较复杂了。对于前面那些名为`f`的函数，我们来分析如下的调用会发生什么情况：
```cpp
(42,2.56);
```

选择可行函数的方法和只有一个实参是一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。在此例中，可行函数包括`f(int,int)`和`f(double,doubel)`。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。

如果有且仅有一个函数满足下列条件，则匹配成功：
- 该函数每个实参的匹配不劣于其他可行函数需要的匹配。
- 至少有一个实参的匹配优于其他可行函数提供的匹配。

如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。

在上面的调用中，只考虑第一个实参时我们发现函数`f(int,int)`能精确匹配；要想匹配第二个函数，`int`类型的实参必须转换成`double`类型。显然需要内置类型转换的匹配劣于精确匹配，因此就第一个实参而言，`f(int,int)`比`f(double,double)`更好。

接着考虑第二个实参，此时`f(double,double)`是精确匹配；要想调用`f(int,int)`必须将`double`类型转换成`int`。因此就第二个实参来说，`f(double,double)`更好。

编译器最终因为这两个调用具有二义性而拒绝其请求：因为每个可行函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。看起来我们似乎可以通过强制类型转换其中的一个实参来实现函数的匹配，但是在设计良好的系统中，不应该对实参进行强制类型转换。

## 实参类型转换
为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：
- 精确匹配
    - 实参类型和形参类型相同
    - 实参从数组类型或函数类型转换成对应的指针类型
    - 向实参添加顶层`const`或者从实参中删除顶层`const`
- 通过`const`转换实现的匹配
- 通过类型提升实现的匹配
- 通过算术类型转换或指正转换实现的匹配
- 通过类类型转换实现的匹配

**需要类型提升和算术类型转换的匹配**

分析函数调用前，我们应该知道小整型一般都会提升到`int`类型或更大的整数类型。假设有两个函数，一个接受`int`、另一个接受`short`，则只有当调用提供的是`short`类型的值时才会选择`short`版本的函数。有时候，即使实参是一个很小的整数值，也会直接将它提升成`int`类型；此时使用`short`版本反而可能导致类型转换：
```cpp
void ff(int);
void ff(short);
ff('a');            //char提升成int，调用ff(int)
```

所有算术类型转换的级别都一样。例如，从`int`向`unsigned int`类型转换并不比从`int`向`double`的转换级别高。

举个具体点的例子，考虑：
```cpp
void manip(long);
void manip(float);
manip(3.14);        //错误：二义性调用
```

**函数匹配和const实参**

如果重载函数的区别在于它们的引用类型的形参是否引用了`const`，或者指针类型的形参是否指向`const`，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数：
```cpp
int lookup(int&);
int lookup(const int&);
const int a;
int b;

lookup(a);                    //调用lookup(int&)
lookup(b);                    //调用lookup(const int&)
```

指针类型的形参也类似。如果两个函数的唯一区别是它的指针形参指向常量或非常量，则编译器能通过实参是否是常量决定选用哪个函数：如果实参是指向常量的指针，调用形参是`const *`的函数；如果实参是指向非常量的指针，调用形参是普通指针的函数。