# C6.5 特殊用途语言特性
## 默认实参
某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的**默认实参（default argument）**。 调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

例如，我们使用`string`对象表示窗口中的内容。一般情况下，我们希望窗口的高、宽和背景字符都使用默认值。但是同时我们也应该允许用户为这几个参数自由指定与默认值不同的数值。为了使的窗口函数既能接纳默认值，也能接受用户指定的值，我们把它定义成如下的形式：
```cpp
typedef string::size_type sz;
string screen(sz ht = 24,sz wid = 80,char bg = ' ');
```

我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参给赋予了默认值，它后面的所有形参都必须有默认值。

### 使用默认实参调用函数
如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。例如，`screen`函数为它的所有形参都提供了默认实参，所以我们可以使用0、1、2或3个实参调用该函数：
```cpp
string window;
window = screen();
window = screen(66);
window = screen(66,256);
window = screen(66,256,'#');
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。例如，要想覆盖`bg`的默认值，必须为`ht`和`wid`提供实参：
```cpp
window = screen(,,'$');        //错误：只能省略尾部的实参
window = screen('$');          //调用screen('?',80,' ')
```

当设计含有默认实参的函数时，其中一项任务就是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

### 默认实参声明
对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

### 默认实参初始值
局部变量不能作为默认值。除此之外，只要表达式的类型可以转换成形参所需要的类型，该表达式就能作为默认实参：
```cpp
//wd,def和ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(),sz = wd,char = def);

string window = screen();                        //调用screen(ht(),80,' ')
```

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：
```cpp
void f2()
{
    def = '*';
    sz wd = 100;                  //隐藏了外层定义的wd，但是没有改变默认值
    window = screen();            //调用screen(ht(),80,'*')
}
```

我们在函数`f2`内部改变了`def`的值，所以对`screen`的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的`wd`，但是该局部变量与传递给`screen`的默认实参没有任何关系。

## 内联函数和constexpr函数
把一些小规模的操作定义成函数有很多好处，主要包括：
- 阅读和理解函数的调用要比读懂等价的条件表达式容易得多
- 使用函数可以确保行为的统一，每次相关操作都能够保证按照相同的方式进行
- 如果我们需要修改计算过程，显然修改函数要比先找到等价表达式所有出现的地方在逐一修改更容易
- 函数可以被其它应用反复利用，省去了重新编写的代价

然而，使用函数存在一些潜在的缺点：调用函数比一般求等价表达式的值要慢一些。
### 内联函数可以避免函数调用的开销
将函数指定成**内联函数（inline）**，通常就是将它在每个调用点上“内联地”展开。

我们可以在一个函数的返回类型前加上关键字`inline`，这样就可以将它声明成内联函数了：
```cpp
inline const string& shorterString(const string &s1,const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。